<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TREP-PD - Transmisión de Resultados Electorales Preliminares Poder Deportivo</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <style>
    :root {
      --bg-color: #f4f7f6;
      --brand-color: #1a237e;
    }
    body { background-color: var(--bg-color); }
    .brand { font-size: 1.2rem; font-weight: 700; color: var(--brand-color); }
    .card-scrollable-content {
      max-height: 650px; /* Altura máxima para el contenido */
      overflow-y: auto;  /* Añade una barra de scroll si el contenido es más alto */
      padding-right: 5px; /* Espacio para la barra de scroll */
    }
  </style>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="container mt-4">
    <header class="d-flex justify-content-between align-items-center mb-3">
      <div class="brand">TREP-PD | Transmisión de Resultados Electorales Preliminares Poder Deportivo</div>
      <div id="lastUpdated" class="text-muted small">Última actualización: --</div>
    </header>

    <div id="important-notice" class="alert alert-warning" role="alert" style="transition: opacity 0.5s ease-out;">
      <strong>Aviso Importante:</strong> Los datos presentados son preliminares y provienen exclusivamente de nuestros corresponsales en cada uno de los centros de votación en <strong>El Progreso, Yoro</strong>.
      Estos resultados no son definitivos y no declaran a ningún candidato como ganador.
    </div>

    <div class="row g-4">
      <!-- Presidenciales -->
      <div class="col-lg-6">
        <div class="card h-100">
          <div class="card-header">
            <h3 class="card-title mb-0">Presidenciales</h3>
          </div>
          <div class="card-body d-flex flex-column">
            <div id="summaryPres" class="border-bottom pb-2 mb-3"></div>
            <div class="card-scrollable-content">
              <canvas id="chartPres"></canvas>
              <table id="tablePres" class="table table-striped mt-3">
                <thead><tr><th>Candidato</th><th>Votos</th><th>%</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Alcaldes -->
      <div class="col-lg-6">
        <div class="card h-100">
          <div class="card-header">
            <h3 class="card-title mb-0">Alcaldes</h3>
          </div>
          <div class="card-body d-flex flex-column">
            <div id="summaryAlc" class="border-bottom pb-2 mb-3"></div>
            <div class="card-scrollable-content">
              <canvas id="chartAlc"></canvas>
              <table id="tableAlc" class="table table-striped mt-3">
                <thead><tr><th>Candidato</th><th>Votos</th><th>%</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* CONFIG: Pega aquí la URL de tu aplicación web de Google Apps Script */
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxJq8VFpY9yi9G5tWyPnQmue4Ww_6Yn_wS6ess2K0Qj3y78TnhaeF4sIkhnevw0L1AR/exec"; // <-- ¡REEMPLAZA ESTO!

const CSV_URL_PRES = `${SCRIPT_URL}?gid=0`;       // GID de la hoja de Presidenciales
const CSV_URL_ALC  = `${SCRIPT_URL}?gid=353257859`; // GID de la hoja de Alcaldes

/* CONFIG: Censo electoral local (sin contar el extranjero) */
const CENSO_TOTAL = 6026477;

/* Utility: simple CSV parser (works con CSV básico, sin comillas complejas) */
function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/); // Más robusto para saltos de línea
  return lines.map(l => l.split(',').map(c => c.trim()));
}

/* Fetch and map CSV to {labels:[], totals:[]} */
async function fetchTotals(csvUrl) {
  const res = await fetch(csvUrl);
  if (!res.ok) throw new Error('CSV fetch failed: ' + res.status);
  const txt = await res.text();
  const rows = parseCSV(txt);
  // Necesitamos al menos 2 filas: cabeceras e imágenes
  if (rows.length < 2) return { labels: [], totals: [], imageUrls: [] };

  const headers = rows[0];
  const candidateHeaders = {};

  // 1. Identificar las columnas para cada candidato (Urna y Votos)
  headers.forEach((header, index) => {
    const candidateName = header.replace(/\s*\((Urna|Votos)\)/g, '').trim();
    if (!candidateHeaders[candidateName]) {
      candidateHeaders[candidateName] = {};
    }
    if (header.includes('(Urna)')) {
      candidateHeaders[candidateName].urnaCol = index;
    }
    if (header.includes('(Votos)')) {
      candidateHeaders[candidateName].votosCol = index;
    }
  });

  const labels = Object.keys(candidateHeaders);
  const totals = new Array(labels.length).fill(0);
  const candidateVoteMaps = labels.map(() => new Map());

  // Fila 2: URLs de las imágenes
  const imageUrls = labels.map(name => rows[1][candidateHeaders[name].urnaCol] || rows[1][candidateHeaders[name].votosCol]);

  // 2. Procesar votos a partir de la fila 3 usando los índices de columna correctos
  for (let r = 2; r < rows.length; r++) {
    labels.forEach((name, i) => {
      const { urnaCol, votosCol } = candidateHeaders[name];
      // Asegurarse de que ambas columnas fueron identificadas
      if (urnaCol === undefined || votosCol === undefined) return;

      const urna = rows[r][urnaCol];
      const votosStr = rows[r][votosCol];

      if (!urna || !votosStr) return;
      const votos = parseInt(votosStr, 10);
      if (!isNaN(votos)) candidateVoteMaps[i].set(urna, votos);
    });
  }

  // 3. Sumar los valores únicos de cada mapa para obtener el total final
  candidateVoteMaps.forEach((voteMap, i) => { totals[i] = Array.from(voteMap.values()).reduce((sum, v) => sum + v, 0); });

  return { labels, totals, imageUrls };
}

/* Chart helpers */
let chartPres=null, chartAlc=null;

// Paleta de colores para los candidatos
const CHART_COLORS = ['#36a2eb', '#4bc0c0', '#9966ff', '#ffcd56', '#c9cbcf']; // Colores de fallback

// Colores específicos por partido
const PARTY_COLORS = {
  '(PNH)': '#00529F',   // Azul Marino para el Partido Nacional
  '(PLH)': '#E41E26',   // Rojo para el Partido Liberal
  '(LIBRE)': '#F05A28', // Naranja para el Partido Libre
};

const DEFAULT_COLOR = '#6c757d'; // Un color gris para candidatos sin partido definido

const candidateImagesPlugin = {
  id: 'candidateImages',
  async afterDraw(chart, args, options) {
    const { ctx } = chart;
    const { imageUrls } = options;
    if (!imageUrls || imageUrls.length === 0) return;

    const imageSize = 30; // Tamaño de la imagen en píxeles
    const meta = chart.getDatasetMeta(0);

    for (let i = 0; i < meta.data.length; i++) {
      const bar = meta.data[i];
      const imageUrl = imageUrls[i];
      if (!imageUrl || imageUrl.trim() === '') continue;

      // Usamos un caché simple para no recargar imágenes
      if (!chart.customImages) chart.customImages = {};
      let img = chart.customImages[imageUrl];

      if (!img) {
        img = new Image();
        img.src = imageUrl;
        chart.customImages[imageUrl] = img;
        // Si la imagen no ha cargado, la dibujamos en el siguiente ciclo de animación
        img.onload = () => chart.draw();
      }

      if (img.complete) {
        // Para barras horizontales, la imagen va a la izquierda, cerca de la etiqueta.
        // 'bar.y' es el centro vertical de la barra.
        // 'chart.chartArea.left' es donde empieza el área del gráfico.
        // Colocamos la imagen a la izquierda de esa área.
        const x = chart.chartArea.left - imageSize - 5;
        const y = bar.y - (imageSize / 2);

        ctx.save();
        ctx.beginPath();
        // Dibuja un círculo para recortar la imagen
        ctx.arc(x + imageSize / 2, y + imageSize / 2, imageSize / 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(img, x, y, imageSize, imageSize);
        ctx.restore();
      }
    }
  }
};

Chart.register(candidateImagesPlugin);

function renderBarChart(canvasId, labels, values, title, imageUrls){
  const ctx = document.getElementById(canvasId);
  if(!ctx) return;
  const data = {
    labels,
    datasets: [{
      label: title,
      data: values,
      backgroundColor: labels.map((label, i) => {
        // Busca si el nombre del candidato contiene una sigla de partido
        for (const party in PARTY_COLORS) {
          if (label.includes(party)) {
            return PARTY_COLORS[party];
          }
        }
        // Si no se encuentra un partido, usa un color de la paleta de fallback
        // o un color por defecto si la paleta se agota.
        return CHART_COLORS[i % CHART_COLORS.length] || DEFAULT_COLOR;
      }),
      // Hacemos las barras del gráfico de alcaldes más delgadas para que coincidan con los otros
      barPercentage: canvasId === 'chartAlc' ? 0.6 : 0.9,
      // También podemos definir un grosor máximo en píxeles
      maxBarThickness: 40,
      // Juntamos más las barras en el gráfico de alcaldes para reducir la altura total
      categoryPercentage: canvasId === 'chartAlc' ? 0.9 : 0.8,
    }]
  };
  const gridColor = 'rgba(0, 0, 0, 0.1)';
  const labelColor = 'rgba(0, 0, 0, 0.8)';

  const cfg = {
    type:'bar',
    data,
    options:{
      indexAxis: 'y', // Barras horizontales para mejor legibilidad
      // Mantenemos las animaciones de interacción (tooltips) pero desactivamos la de carga inicial
      animation: {
        duration: 0
      },
      // Desactiva completamente las interacciones de hover
      hover: {
        mode: null
      },
      // Ajusta el padding izquierdo para dar espacio a las imágenes y etiquetas largas
      layout: {
        padding: { left: 40 }
      },
      plugins: {
        legend:{display:false},
        tooltip: { enabled: false }, // <-- Desactiva el pop-up al pasar el mouse
        candidateImages: { imageUrls } // Pasamos las URLs al plugin
      },
      scales: {
        y: { ticks: { color: labelColor }, grid: { color: gridColor } },
        x: { ticks: { color: labelColor }, grid: { color: gridColor } }
      }
    }
  };

  // Busca si el gráfico ya existe para actualizarlo, en lugar de destruirlo
  let chartInstance = null;
  if (canvasId === 'chartPres') chartInstance = chartPres;
  if (canvasId === 'chartAlc') chartInstance = chartAlc;

  if (chartInstance) {
    // Si el gráfico ya existe, solo actualizamos sus datos y configuración
    chartInstance.data = data;
    chartInstance.options = cfg.options;
    chartInstance.update();
  } else {
    // Si es la primera vez, creamos el gráfico nuevo
    const newChart = new Chart(ctx, cfg);
    if (canvasId === 'chartPres') chartPres = newChart;
    if (canvasId === 'chartAlc') chartAlc = newChart;
  }
}

/* Table render for presidenciales */
function renderTable(tableId, labels, values, totalVotes){
  const tbody = document.querySelector(`#${tableId} tbody`);
  if (!tbody) return;
  tbody.innerHTML = '';
  const totalForPercentage = totalVotes || 1; // Evita división por cero
  for(let i=0;i<labels.length;i++){
    const tr = document.createElement('tr');
    const p = Math.round((values[i]/totalForPercentage)*1000)/10;
    tr.innerHTML = `<td>${labels[i]}</td><td>${values[i].toLocaleString('es-HN')}</td><td>${p}%</td>`;
    tbody.appendChild(tr);
  }
}

/* Helper para ordenar los datos de mayor a menor */
function sortData(data) {
  // 1. Combina etiquetas y totales en un solo array de objetos
  const combined = data.labels.map((label, index) => ({
    label: label,
    total: data.totals[index],
    imageUrl: data.imageUrls[index] // Mantenemos la URL asociada
  }));

  // 2. Ordena el array combinado de mayor a menor voto
  combined.sort((a, b) => b.total - a.total);

  // 3. Separa nuevamente en dos arrays, ya ordenados
  const sortedLabels = combined.map(item => item.label);
  const sortedTotals = combined.map(item => item.total);
  const sortedImageUrls = combined.map(item => item.imageUrl);

  return { labels: sortedLabels, totals: sortedTotals, imageUrls: sortedImageUrls };
}

/* Main refresh flow */
async function refreshAll(){
  const statusEl = document.getElementById('lastUpdated');
  statusEl.textContent = 'Actualizando datos...';

  try{
    const t0 = Date.now();
    let [pres, alc] = await Promise.all([ // Usamos 'let' para poder reasignar
      fetchTotals(CSV_URL_PRES),
      fetchTotals(CSV_URL_ALC),
    ]);

    // Ordenamos los datos de cada elección
    pres = sortData(pres);
    alc = sortData(alc);

    // --- Calcular y renderizar totales ---
    const totalPres = pres.totals.reduce((a, b) => a + b, 0);
    const totalAlc = alc.totals.reduce((a, b) => a + b, 0);

    const participationPres = ((totalPres / CENSO_TOTAL) * 100).toFixed(2);
    const participationAlc = ((totalAlc / CENSO_TOTAL) * 100).toFixed(2);

    document.getElementById('summaryPres').innerHTML = `<strong>Total Votos:</strong> ${totalPres.toLocaleString('es-HN')} | <strong>Participación:</strong> ${participationPres}%`;
    document.getElementById('summaryAlc').innerHTML = `<strong>Total Votos:</strong> ${totalAlc.toLocaleString('es-HN')} | <strong>Participación:</strong> ${participationAlc}%`;


    // Renderizamos todo con los datos ya ordenados
    renderBarChart('chartPres', pres.labels, pres.totals, 'Votos Presidenciales', pres.imageUrls);
    renderTable('tablePres', pres.labels, pres.totals, totalPres);
    renderBarChart('chartAlc', alc.labels, alc.totals, 'Votos Alcaldes', alc.imageUrls);
    renderTable('tableAlc', alc.labels, alc.totals, totalAlc);

    // last updated
    statusEl.textContent = 'Última actualización: ' + new Date().toLocaleString('es-HN');
    console.log('Refreshed in', Date.now()-t0,'ms');
  }catch(err){
    console.error('Refresh error',err);
    statusEl.textContent = 'Error actualizando: '+err.message;
  }
}

/* Auto-refresh */
// Inicia la carga de datos
refreshAll(); // Carga inicial
setInterval(refreshAll, 120000); // Actualiza cada 2 minutos (ajustable)
</script>

<script>
  // Ocultar el banner de aviso después de 40 segundos
  setTimeout(() => {
    const notice = document.getElementById('important-notice');
    if (notice) {
      notice.style.opacity = '0';
      // Espera a que termine la transición para ocultarlo completamente
      setTimeout(() => { notice.style.display = 'none'; }, 500);
    }
  }, 40000); // 40000 milisegundos = 40 segundos
</script>
</body>
</html>
